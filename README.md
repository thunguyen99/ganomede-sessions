Match-Maker
-----------

Play against randomly picked opponents.

Relations
---------

The match-maker module will:

 * Keep an in-memory list of players looking for opponents..
 * Use the `redis_auth` database to check requester identity.
 * Create a gameID using the `coordinator` API.

Configuration
-------------

 * `COORDINATOR_PORT_8080_TCP_ADDR` - IP of the coordinator service
 * `COORDINATOR_PORT_8080_TCP_PORT` - Port of the coordinator service
 * `REDIS_AUTH_PORT_6379_TCP_ADDR` - IP of the AuthDB redis
 * `REDIS_AUTH_PORT_6379_TCP_PORT` - Port of the AuthDB redis

API
---

All requests made to the match-maker API require an auth token, passed in the request URL.

# Random Opponents [/matchmaker/v1/auth/:token/type/:type/:version/players/:nplayers]

    + Parameters
        + token (string) ... User authentication token
        + type (string) ... Type of game (without version). eg. `substract`
        + version (string) ... Version of game. eg. `v1`
        + nplayers (int) ... Number of players requested

## Find opponents [GET]

### response [200] OK

    {
        "id": "... gameID generated by coordinator ..."
    }

### response [408] Request Timeout

## Design notes

The request will be hold until either enough opponents are found, or the timeout occurs.

The server maintains in memory a map of lists.

 * the `key` equals to "#{type}/#{version}/#{nplayers}"
 * the lists containing the users looking for opponents .

When a request comes in, server checks into the appropriate list. If there are **enough players** to start a game, it'll:

 * clear the list
 * cleanup everyone's "timeout"
 * create a game using the coordinator
 * reply to everyone in the list 200, with the ID of the generated game

If there are **not enough players**, it will:

 * setup a timeout
 * add the player into the list `(username, successCb, timeout)`

When **timeout occurs**, the server will:

 * remove the user from its list
 * reply with 408 (Request Timeout)

